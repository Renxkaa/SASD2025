
# Message Chain
โค้ดที่ต้องเรียก method ต่อกันหลาย ๆ ชั้น เพื่อจะให้ได้ข้อมูลที่ต้องการ เหมือนกับ ขอของเพื่อนแล้วเพื่อนบอกให้ไปถามอีกคนและอีกคนบอกให้ไปถามอีกคน ทำให้โค้ดยาว อ่านยาก และต้องรู้โครงสร้างข้างในของ object มากเกินไป
ตัวอย่างเช่น 
order.getCustomer().getAddress().getCity();

## b) ตัวอย่างโค้ดที่เกิด Message Chain

~~~
class OrderService {
    public String getCustomerCity(Order order) {
        return order.getCustomer()
                    .getAddress()
                    .getCity();
    }
}
~~~

**ปัญหา:**
* OrderService รู้ลึกถึงโครงสร้างของ Order → Customer → Address
* ถ้าเปลี่ยนโครงสร้าง (เช่น ย้าย Address) ต้องแก้หลายจุด


## c) ตัวอย่างโค้ดที่ Refactoring แล้ว

**วิธีที่ 1: ให้ object ที่มีข้อมูลนั้นเป็นคนตอบคำถามเอง**
~~~
class Order {
    private Customer customer;

    public String getCustomerCity() {
        return customer.getCity();
    }
}

class Customer {
    private Address address;

    public String getCity() {
        return address.getCity();
    }
}
~~~
เรียกใช้งาน:
~~~
class OrderService {
    public String getCustomerCity(Order order) {
        return order.getCustomerCity();
    }
}
~~~

ข้อดี:
* ลด message chain
* Encapsulation ดีขึ้น
* โค้ดอ่านง่าย และแก้ง่าย

## d) กรณีที่ Message Chain ไม่จำเป็นต้อง Refactoring
Message Chain ไม่เสมอไป ว่าจะเป็นปัญหา ในบางกรณีสามารถยอมรับได้ เช่น:
**วิธีที่ 1 โค้ดสำหรับอ่านข้อมูลอย่างเดียว (Read-only / DTO)**
~~~
String city = response.getData()
                      .getUser()
                      .getProfile()
                      .getCity();
~~~
เหตุผล:
* เป็น DTO หรือ API response
* ไม่มี business logic
* ไม่คาดว่าจะเปลี่ยนโครงสร้างบ่อย

**วิธีที่ 2 โค้ดที่ใช้กับ Fluent Interface / Builder**
~~~
query.select("name")
     .from("users")
     .where("age > 18")
     .orderBy("name");
~~~
เหตุผล:
* ถูกออกแบบมาให้ chain โดยตั้งใจ
* อ่านง่าย และเป็น pattern ที่เหมาะสม

**วิธีที่ 3 โค้ดขนาดเล็ก ใช้ครั้งเดียว และไม่ซับซ้อน**
~~~
String country = order.getCustomer().getAddress().getCountry();
~~~
เหตุผล:
* ไม่ได้ใช้ซ้ำ
* ไม่ทำให้ระบบซับซ้อน
* Refactor แล้วอาจทำให้โค้ดยาวและรกกว่าเดิม
