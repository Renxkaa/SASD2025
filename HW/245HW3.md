
# HW3 – ตัวอย่าง C# Class 3 ประเภท

## 1) Utility Class

### ตัวอย่างคลาส: `System.Math`  
เอกสารอ้างอิง:  
https://learn.microsoft.com/en-us/dotnet/api/system.math  

### ลักษณะของคลาส

- เป็น `static class`
- มีแต่ `static method`
- ไม่สามารถสร้าง object ได้
- ไม่มีการเก็บข้อมูลภายใน (ไม่มี state)

### ตัวอย่างการใช้งาน

```csharp
double x = Math.Sqrt(25);
int y = Math.Max(10, 20); 
```
### วิเคราะห์

#### 

 - State -> คลาส `Math` ไม่มีการเก็บข้อมูลไว้ภายในเลย  ทุกครั้งที่เรียกใช้งาน จะรับค่าที่ส่งเข้าไป คำนวณ แล้วส่งผลลัพธ์กลับทันที

####

 - Encapsulation -> แต่ละ method ทำงานแยกกันอย่างชัดเจน  ไม่มีการไปยุ่งกับข้อมูลของ object อื่น ๆ

####

 - Memory ->ไม่ต้องสร้าง object ก่อนใช้งาน  จึงไม่ต้องใช้หน่วยความจำสำหรับ instance
### สรุป
`System.Math` เป็น **Utility Class**  เพราะเป็นคลาสที่รวมฟังก์ชันสำหรับช่วยคำนวณต่าง ๆ  
ใช้งานผ่านชื่อคลาสได้เลย และไม่มีการเก็บข้อมูลภายใน

---

## 2) Mutable Class

### ตัวอย่างคลาส: `System.Collections.Generic.List<T>`

เอกสารอ้างอิง:  
https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1

### ลักษณะของคลาส

- เป็น class ปกติ (ไม่ใช่ static)
- มีการเก็บข้อมูลภายใน
- สามารถเพิ่ม/ลบ/แก้ไขข้อมูลได้หลังจากสร้าง object แล้ว

### ตัวอย่างการใช้งาน

```csharp
var list = new List<int>();
list.Add(5);
list.Add(10);
list.Remove(5);
```
### วิเคราะห์

#### 
- State -> `List<T>` มีข้อมูลสมาชิกเก็บอยู่ภายใน  ข้อมูลนี้สามารถเปลี่ยนแปลงได้ตลอดเวลา

#### 

 - Encapsulation -> เราไม่สามารถเข้าถึง array ภายในได้โดยตรง  ต้องแก้ไขผ่าน method เช่น `Add()`, `Remove()`, `Clear()`

#### 

 - Memory -> object ที่สร้างขึ้นยังคงเป็นตัวเดิม  แต่ข้อมูลที่อยู่ข้างในสามารถเปลี่ยนได้

####

 - Object Identity -> แม้ข้อมูลจะเปลี่ยน แต่ reference ของ object ยังเหมือนเดิม

### สรุป

`List<T>` เป็น **Mutable Class**  เพราะสามารถเปลี่ยนแปลง state ภายในได้หลังจากสร้าง object แล้ว

## 3) Immutable Class

### ตัวอย่างคลาส: `System.String`

เอกสารอ้างอิง:  
[https://learn.microsoft.com/en-us/dotnet/api/system.string](https://learn.microsoft.com/en-us/dotnet/api/system.string)

### ลักษณะของคลาส

-   ไม่มี method ที่แก้ไขค่าภายใน object เดิม
    
-   ไม่มี setter
    
-   ถ้ามีการเปลี่ยนค่า จะสร้าง object ใหม่แทน
    

### ตัวอย่างการใช้งาน
```markdown
string name = "John";
name = name.ToUpper(); 
```

 - List item

### สิ่งที่เกิดขึ้นจริง

-   `"John"` ไม่ถูกแก้ไข
    
-   `ToUpper()` สร้าง string ใหม่ `"JOHN"`
    
-   ตัวแปร `name` ชี้ไปยัง object ใหม่
    

### วิเคราะห์

#### 

 - State -> เมื่อสร้าง string แล้ว ค่าภายในจะไม่สามารถเปลี่ยนได้

#### 

 - Encapsulation ->ไม่มีวิธีใดที่สามารถแก้ไขตัวอักษรภายใน string เดิมได้โดยตรง

#### 

 - Memory -> ทุกครั้งที่เปลี่ยนค่า จะสร้าง object ใหม่  ไม่ได้แก้ไขของเดิม

#### ข้อดี

ปลอดภัยต่อการใช้งานร่วมกันหลายส่วนของโปรแกรม  เพราะไม่มีใครสามารถเปลี่ยนค่าของ string เดิมได้

### สรุป

`System.String` เป็น **Immutable Class**  เพราะไม่สามารถเปลี่ยนแปลงค่าภายในได้หลังจากสร้างแล้ว
---

# ตารางสรุปเปรียบเทียบ

| ประเภท | ตัวอย่าง | มี State | เปลี่ยนค่าได้ | ต้องสร้าง Object |
|---------|----------|----------|---------------|------------------|
| Utility | Math | ไม่มี | ไม่เกี่ยวข้อง | ไม่ต้อง |
| Mutable | List<T> | มี | ได้ | ต้อง |
| Immutable | String | มี | ไม่ได้ | ต้อง |
---
# บทสรุปภาพรวม

ในการออกแบบเชิงวัตถุ (OOD) การเข้าใจความแตกต่างของ Utility, Mutable และ Immutable Class มีความสำคัญมาก

-   Utility Class เหมาะกับฟังก์ชันช่วยเหลือทั่วไป
    
-   Mutable Class เหมาะกับ object ที่ต้องมีการเปลี่ยนแปลงข้อมูล
    
-   Immutable Class เหมาะกับข้อมูลที่ไม่ควรถูกแก้ไข
    

การเลือกใช้ประเภทของคลาสให้เหมาะสม จะช่วยให้โปรแกรมอ่านง่าย เข้าใจง่าย และดูแลรักษาได้ดีในระยะยาว

